package cmd

import (
	"bufio"
	"context"
	"fmt"
	"log/slog"
	"os"
	"strings"

	"github.com/go-acme/lego/v5/cmd/internal/storage"
	"github.com/go-acme/lego/v5/lego"
	"github.com/go-acme/lego/v5/log"
	"github.com/go-acme/lego/v5/registration"
	"github.com/go-acme/lego/v5/registration/zerossl"
	"github.com/urfave/cli/v3"
)

const rootPathWarningMessage = `!!!! HEADS UP !!!!

Your account credentials have been saved in your
configuration directory at "%s".

You should make a secure backup of this folder now. This
configuration directory will also contain private keys
generated by lego and certificates obtained from the ACME
server. Making regular backups of this folder is ideal.
`

func createRegister() *cli.Command {
	return &cli.Command{
		Name:   "register",
		Usage:  "Register an account.",
		Action: register,
		Flags:  createRegisterFlags(),
	}
}

func register(ctx context.Context, cmd *cli.Command) error {
	keyType, err := getKeyType(cmd.String(flgKeyType))
	if err != nil {
		return fmt.Errorf("get the key type: %w", err)
	}

	accountsStorage, err := storage.NewAccountsStorage(newAccountsStorageConfig(cmd))
	if err != nil {
		return fmt.Errorf("accounts storage initialization: %w", err)
	}

	account, err := accountsStorage.Get(ctx, keyType, cmd.String(flgEmail), cmd.String(flgAccountID))
	if err != nil {
		return fmt.Errorf("set up account: %w", err)
	}

	if account.Registration == nil {
		client, err := newClient(cmd, account, keyType)
		if err != nil {
			return fmt.Errorf("new client: %w", err)
		}

		reg, err := registerAccount(ctx, cmd, client)
		if err != nil {
			return fmt.Errorf("could not complete registration: %w", err)
		}

		account.Registration = reg
		if err = accountsStorage.Save(account); err != nil {
			return fmt.Errorf("could not save the account file: %w", err)
		}

		fmt.Printf(rootPathWarningMessage, accountsStorage.GetRootPath())
	} else {
		log.Info("Account already registered, skipping.")
	}

	return nil
}

func registerAccount(ctx context.Context, cmd *cli.Command, client *lego.Client) (*registration.Resource, error) {
	accepted := handleTOS(cmd, client)
	if !accepted {
		log.Fatal("You did not accept the TOS. Unable to proceed.")
	}

	if cmd.Bool(flgEAB) {
		kid := cmd.String(flgEABKID)
		hmacEncoded := cmd.String(flgEABHMAC)

		if kid == "" || hmacEncoded == "" {
			log.Fatal(fmt.Sprintf("Requires arguments --%s and --%s.", flgEABKID, flgEABHMAC))
		}

		return client.Registration.RegisterWithExternalAccountBinding(ctx, registration.RegisterEABOptions{
			TermsOfServiceAgreed: accepted,
			Kid:                  kid,
			HmacEncoded:          hmacEncoded,
		})
	} else if zerossl.IsZeroSSL(cmd.String(flgServer)) {
		return registration.RegisterWithZeroSSL(ctx, client.Registration, cmd.String(flgEmail))
	}

	return client.Registration.Register(ctx, registration.RegisterOptions{TermsOfServiceAgreed: true})
}

func handleTOS(cmd *cli.Command, client *lego.Client) bool {
	// Check for a global accept override
	if cmd.Bool(flgAcceptTOS) {
		return true
	}

	reader := bufio.NewReader(os.Stdin)

	log.Warn("Please review the TOS", slog.String("url", client.GetToSURL()))

	for {
		fmt.Println("Do you accept the TOS? Y/n")

		text, err := reader.ReadString('\n')
		if err != nil {
			log.Fatal("Could not read from the console", log.ErrorAttr(err))
		}

		text = strings.Trim(text, "\r\n")
		switch text {
		case "", "y", "Y":
			return true
		case "n", "N":
			return false
		default:
			fmt.Println("Your input was invalid. Please answer with one of Y/y, n/N or by pressing enter.")
		}
	}
}
