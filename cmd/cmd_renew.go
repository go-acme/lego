package cmd

import (
	"encoding/json"
	"io/ioutil"
	"path/filepath"
	"strings"
	"time"

	"github.com/urfave/cli"
	"github.com/xenolf/lego/certcrypto"
	"github.com/xenolf/lego/certificate"
	"github.com/xenolf/lego/log"
)

func createRenew() cli.Command {
	return cli.Command{
		Name:   "renew",
		Usage:  "Renew a certificate",
		Action: renew,
		Flags: []cli.Flag{
			cli.IntFlag{
				Name:  "days",
				Value: 0,
				Usage: "The number of days left on a certificate to renew it.",
			},
			cli.BoolFlag{
				Name:  "reuse-key",
				Usage: "Used to indicate you want to reuse your current private key for the new certificate.",
			},
			cli.BoolFlag{
				Name:  "no-bundle",
				Usage: "Do not create a certificate bundle by adding the issuers certificate to the new certificate.",
			},
			cli.BoolFlag{
				Name:  "must-staple",
				Usage: "Include the OCSP must staple TLS extension in the CSR and generated certificate. Only works if the CSR is generated by lego.",
			},
		},
	}
}

func renew(c *cli.Context) error {
	conf, acc, client := setup(c)
	if acc.Registration == nil {
		log.Fatalf("Account %s is not registered. Use 'run' to register a new account.\n", acc.Email)
	}

	if len(c.GlobalStringSlice("domains")) <= 0 {
		log.Fatal("Please specify at least one domain.")
	}

	domain := c.GlobalStringSlice("domains")[0]
	domain = strings.Replace(domain, "*", "_", -1)

	// load the cert resource from files.
	// We store the certificate, private key and metadata in different files
	// as web servers would not be able to work with a combined file.
	certPath := filepath.Join(conf.CertPath(), domain+".crt")
	privPath := filepath.Join(conf.CertPath(), domain+".key")
	metaPath := filepath.Join(conf.CertPath(), domain+".json")

	certBytes, err := ioutil.ReadFile(certPath)
	if err != nil {
		log.Fatalf("Error while loading the certificate for domain %s\n\t%v", domain, err)
	}

	if c.IsSet("days") {
		expTime, errE := certcrypto.GetPEMCertExpiration(certBytes)
		if errE != nil {
			log.Printf("Could not get Certification expiration for domain %s", domain)
		}

		if int(time.Until(expTime).Hours()/24.0) > c.Int("days") {
			return nil
		}
	}

	metaBytes, err := ioutil.ReadFile(metaPath)
	if err != nil {
		log.Fatalf("Error while loading the meta data for domain %s\n\t%v", domain, err)
	}

	var certRes certificate.Resource
	if err = json.Unmarshal(metaBytes, &certRes); err != nil {
		log.Fatalf("Error while marshaling the meta data for domain %s\n\t%v", domain, err)
	}

	if c.Bool("reuse-key") {
		keyBytes, errR := ioutil.ReadFile(privPath)
		if errR != nil {
			log.Fatalf("Error while loading the private key for domain %s\n\t%v", domain, errR)
		}
		certRes.PrivateKey = keyBytes
	}

	certRes.Certificate = certBytes

	newCert, err := client.Certificate.Renew(certRes, !c.Bool("no-bundle"), c.Bool("must-staple"))
	if err != nil {
		log.Fatal(err)
	}

	saveCertRes(newCert, conf)

	return nil
}
