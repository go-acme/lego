package cmd

import (
	"bufio"
	"context"
	"fmt"
	"log/slog"
	"os"
	"strings"

	"github.com/go-acme/lego/v5/certificate"
	"github.com/go-acme/lego/v5/cmd/internal/hook"
	"github.com/go-acme/lego/v5/cmd/internal/storage"
	"github.com/go-acme/lego/v5/lego"
	"github.com/go-acme/lego/v5/log"
	"github.com/go-acme/lego/v5/registration"
	"github.com/urfave/cli/v3"
)

const rootPathWarningMessage = `!!!! HEADS UP !!!!

Your account credentials have been saved in your
configuration directory at "%s".

You should make a secure backup of this folder now. This
configuration directory will also contain private keys
generated by lego and certificates obtained from the ACME
server. Making regular backups of this folder is ideal.
`

func createRun() *cli.Command {
	return &cli.Command{
		Name:  "run",
		Usage: "Register an account, then create and install a certificate",
		Before: func(ctx context.Context, cmd *cli.Command) (context.Context, error) {
			// we require either domains or csr, but not both
			hasDomains := len(cmd.StringSlice(flgDomains)) > 0

			hasCsr := cmd.String(flgCSR) != ""
			if hasDomains && hasCsr {
				log.Fatal("Please specify either --domains/-d or --csr/-c, but not both")
			}

			if !hasDomains && !hasCsr {
				log.Fatal("Please specify --domains/-d (or --csr/-c if you already have a CSR)")
			}

			return ctx, nil
		},
		Action: run,
		Flags:  createRunFlags(),
	}
}

func run(ctx context.Context, cmd *cli.Command) error {
	accountsStorage, err := storage.NewAccountsStorage(newAccountsStorageConfig(cmd))
	if err != nil {
		log.Fatal("Accounts storage initialization", log.ErrorAttr(err))
	}

	account, keyType := setupAccount(ctx, cmd, accountsStorage)

	client := setupClient(cmd, account, keyType)

	if account.Registration == nil {
		var reg *registration.Resource

		reg, err = register(ctx, cmd, client)
		if err != nil {
			log.Fatal("Could not complete registration.", log.ErrorAttr(err))
		}

		account.Registration = reg
		if err = accountsStorage.Save(account); err != nil {
			log.Fatal("Could not save the account file.", log.ErrorAttr(err))
		}

		fmt.Printf(rootPathWarningMessage, accountsStorage.GetRootPath())
	}

	certsStorage, err := storage.NewCertificatesStorage(newCertificatesWriterConfig(cmd))
	if err != nil {
		log.Fatal("Certificates storage", log.ErrorAttr(err))
	}

	certsStorage.CreateRootFolder()

	cert, err := obtainCertificate(ctx, cmd, client)
	if err != nil {
		// Make sure to return a non-zero exit code if ObtainSANCertificate returned at least one error.
		// Due to us not returning partial certificate we can just exit here instead of at the end.
		log.Fatal("Could not obtain certificates", log.ErrorAttr(err))
	}

	certsStorage.SaveResource(cert)

	meta := map[string]string{
		hook.EnvAccountEmail: account.Email,
	}

	hook.AddPathToMetadata(meta, cert.Domain, cert, certsStorage)

	return hook.Launch(ctx, cmd.String(flgRunHook), cmd.Duration(flgRunHookTimeout), meta)
}

func handleTOS(cmd *cli.Command, client *lego.Client) bool {
	// Check for a global accept override
	if cmd.Bool(flgAcceptTOS) {
		return true
	}

	reader := bufio.NewReader(os.Stdin)

	log.Warn("Please review the TOS", slog.String("url", client.GetToSURL()))

	for {
		fmt.Println("Do you accept the TOS? Y/n")

		text, err := reader.ReadString('\n')
		if err != nil {
			log.Fatal("Could not read from the console", log.ErrorAttr(err))
		}

		text = strings.Trim(text, "\r\n")
		switch text {
		case "", "y", "Y":
			return true
		case "n", "N":
			return false
		default:
			fmt.Println("Your input was invalid. Please answer with one of Y/y, n/N or by pressing enter.")
		}
	}
}

func register(ctx context.Context, cmd *cli.Command, client *lego.Client) (*registration.Resource, error) {
	accepted := handleTOS(cmd, client)
	if !accepted {
		log.Fatal("You did not accept the TOS. Unable to proceed.")
	}

	if cmd.Bool(flgEAB) {
		kid := cmd.String(flgKID)
		hmacEncoded := cmd.String(flgHMAC)

		if kid == "" || hmacEncoded == "" {
			log.Fatal(fmt.Sprintf("Requires arguments --%s and --%s.", flgKID, flgHMAC))
		}

		return client.Registration.RegisterWithExternalAccountBinding(ctx, registration.RegisterEABOptions{
			TermsOfServiceAgreed: accepted,
			Kid:                  kid,
			HmacEncoded:          hmacEncoded,
		})
	}

	return client.Registration.Register(ctx, registration.RegisterOptions{TermsOfServiceAgreed: true})
}

func obtainCertificate(ctx context.Context, cmd *cli.Command, client *lego.Client) (*certificate.Resource, error) {
	bundle := !cmd.Bool(flgNoBundle)

	domains := cmd.StringSlice(flgDomains)
	if len(domains) > 0 {
		// obtain a certificate, generating a new private key
		request := certificate.ObtainRequest{
			Domains:                        domains,
			MustStaple:                     cmd.Bool(flgMustStaple),
			NotBefore:                      cmd.Timestamp(flgNotBefore),
			NotAfter:                       cmd.Timestamp(flgNotAfter),
			Bundle:                         bundle,
			PreferredChain:                 cmd.String(flgPreferredChain),
			Profile:                        cmd.String(flgProfile),
			AlwaysDeactivateAuthorizations: cmd.Bool(flgAlwaysDeactivateAuthorizations),
		}

		if cmd.IsSet(flgPrivateKey) {
			var err error

			request.PrivateKey, err = storage.LoadPrivateKey(cmd.String(flgPrivateKey))
			if err != nil {
				return nil, fmt.Errorf("load private key: %w", err)
			}
		}

		return client.Certificate.Obtain(ctx, request)
	}

	// read the CSR
	csr, err := readCSRFile(cmd.String(flgCSR))
	if err != nil {
		return nil, err
	}

	// obtain a certificate for this CSR
	request := certificate.ObtainForCSRRequest{
		CSR:                            csr,
		NotBefore:                      cmd.Timestamp(flgNotBefore),
		NotAfter:                       cmd.Timestamp(flgNotAfter),
		Bundle:                         bundle,
		PreferredChain:                 cmd.String(flgPreferredChain),
		Profile:                        cmd.String(flgProfile),
		AlwaysDeactivateAuthorizations: cmd.Bool(flgAlwaysDeactivateAuthorizations),
	}

	if cmd.IsSet(flgPrivateKey) {
		var err error

		request.PrivateKey, err = storage.LoadPrivateKey(cmd.String(flgPrivateKey))
		if err != nil {
			return nil, fmt.Errorf("load private key: %w", err)
		}
	}

	return client.Certificate.ObtainForCSR(ctx, request)
}
