package cmd

import (
	"bufio"
	"crypto/x509"
	"encoding/pem"
	"io/ioutil"
	"os"
	"strings"

	"github.com/urfave/cli"
	"github.com/xenolf/lego/acme"
	"github.com/xenolf/lego/certificate"
	"github.com/xenolf/lego/log"
	"github.com/xenolf/lego/registration"
)

func createRun() cli.Command {
	return cli.Command{
		Name:   "run",
		Usage:  "Register an account, then create and install a certificate",
		Action: run,
		Flags: []cli.Flag{
			cli.BoolFlag{
				Name:  "no-bundle",
				Usage: "Do not create a certificate bundle by adding the issuers certificate to the new certificate.",
			},
			cli.BoolFlag{
				Name:  "must-staple",
				Usage: "Include the OCSP must staple TLS extension in the CSR and generated certificate. Only works if the CSR is generated by lego.",
			},
		},
	}
}

func run(c *cli.Context) error {
	var err error

	conf, acc, client := setup(c)
	if acc.Registration == nil {
		accepted := handleTOS(c, client)
		if !accepted {
			log.Fatal("You did not accept the TOS. Unable to proceed.")
		}

		var reg *registration.Resource

		if c.GlobalBool("eab") {
			kid := c.GlobalString("kid")
			hmacEncoded := c.GlobalString("hmac")

			if kid == "" || hmacEncoded == "" {
				log.Fatalf("Requires arguments --kid and --hmac.")
			}

			reg, err = client.Registration.RegisterWithExternalAccountBinding(
				accepted,
				kid,
				hmacEncoded,
			)
		} else {
			reg, err = client.Registration.Register(accepted)
		}

		if err != nil {
			log.Fatalf("Could not complete registration\n\t%v", err)
		}

		acc.Registration = reg
		err = acc.Save()
		if err != nil {
			log.Fatal(err)
		}

		log.Print("!!!! HEADS UP !!!!")
		log.Printf(`
		Your account credentials have been saved in your Let's Encrypt
		configuration directory at "%s".
		You should make a secure backup	of this folder now. This
		configuration directory will also contain certificates and
		private keys obtained from Let's Encrypt so making regular
		backups of this folder is ideal.`, conf.AccountPath(c.GlobalString("email")))

	}

	// we require either domains or csr, but not both
	hasDomains := len(c.GlobalStringSlice("domains")) > 0
	hasCsr := len(c.GlobalString("csr")) > 0
	if hasDomains && hasCsr {
		log.Fatal("Please specify either --domains/-d or --csr/-c, but not both")
	}
	if !hasDomains && !hasCsr {
		log.Fatal("Please specify --domains/-d (or --csr/-c if you already have a CSR)")
	}

	var cert *certificate.Resource

	if hasDomains {
		// obtain a certificate, generating a new private key
		cert, err = client.Certificate.Obtain(c.GlobalStringSlice("domains"), !c.Bool("no-bundle"), nil, c.Bool("must-staple"))
	} else {
		// read the CSR
		var csr *x509.CertificateRequest
		csr, err = readCSRFile(c.GlobalString("csr"))
		if err == nil {
			// obtain a certificate for this CSR
			cert, err = client.Certificate.ObtainForCSR(*csr, !c.Bool("no-bundle"))
		}
	}

	if err != nil {
		// Make sure to return a non-zero exit code if ObtainSANCertificate returned at least one error.
		// Due to us not returning partial certificate we can just exit here instead of at the end.
		log.Fatalf("Could not obtain certificates:\n\t%v", err)
	}

	if err = checkFolder(conf.CertPath()); err != nil {
		log.Fatalf("Could not check/create path: %v", err)
	}

	saveCertRes(cert, conf)

	return nil
}

func handleTOS(c *cli.Context, client *acme.Client) bool {
	// Check for a global accept override
	if c.GlobalBool("accept-tos") {
		return true
	}

	reader := bufio.NewReader(os.Stdin)
	log.Printf("Please review the TOS at %s", client.GetToSURL())

	for {
		log.Println("Do you accept the TOS? Y/n")
		text, err := reader.ReadString('\n')
		if err != nil {
			log.Fatalf("Could not read from console: %v", err)
		}

		text = strings.Trim(text, "\r\n")

		if text == "n" {
			log.Fatal("You did not accept the TOS. Unable to proceed.")
		}

		if text == "Y" || text == "y" || text == "" {
			return true
		}

		log.Println("Your input was invalid. Please answer with one of Y/y, n or by pressing enter.")
	}
}

func readCSRFile(filename string) (*x509.CertificateRequest, error) {
	bytes, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	raw := bytes

	// see if we can find a PEM-encoded CSR
	var p *pem.Block
	rest := bytes
	for {
		// decode a PEM block
		p, rest = pem.Decode(rest)

		// did we fail?
		if p == nil {
			break
		}

		// did we get a CSR?
		if p.Type == "CERTIFICATE REQUEST" {
			raw = p.Bytes
		}
	}

	// no PEM-encoded CSR
	// assume we were given a DER-encoded ASN.1 CSR
	// (if this assumption is wrong, parsing these bytes will fail)
	return x509.ParseCertificateRequest(raw)
}
